name: Manual Health Check

on:
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of check to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - api-only
          - logs-only
          - frontend-only

permissions:
  contents: read
  issues: write

jobs:
  health-check:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @google-cloud/logging puppeteer

      - name: Create Firebase credentials
        env:
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        run: echo "$FIREBASE_SERVICE_ACCOUNT" > /tmp/firebase-sa.json

      - name: Run Health Check
        id: health
        env:
          GOOGLE_APPLICATION_CREDENTIALS: /tmp/firebase-sa.json
          CHECK_TYPE: ${{ inputs.check_type }}
        run: |
          node << 'EOF'
          const https = require('https');
          const { Logging } = require('@google-cloud/logging');
          const fs = require('fs');

          const APP_URL = 'https://sudoku--sudoku-labs.europe-west4.hosted.app';
          const checkType = process.env.CHECK_TYPE || 'full';
          const results = { passed: [], failed: [] };

          function httpGet(url) {
            return new Promise((resolve, reject) => {
              https.get(url, { timeout: 10000 }, (res) => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve({ status: res.statusCode, headers: res.headers, body: data }));
              }).on('error', reject).on('timeout', () => reject(new Error('Timeout')));
            });
          }

          async function checkAPIs() {
            console.log('\nüì° API CHECKS\n');
            
            const endpoints = [
              { name: 'Ping', url: `${APP_URL}/api?action=ping`, expect: 'ok' },
              { name: 'Generate Sudoku', url: `${APP_URL}/api?action=generateSudoku&difficulty=Easy`, expect: 'id' },
              { name: 'Leaderboard', url: `${APP_URL}/api?action=getLeaderboard`, expect: '[' }
            ];

            for (const ep of endpoints) {
              try {
                const res = await httpGet(ep.url);
                if (res.status === 200 && res.body.includes(ep.expect)) {
                  console.log(`‚úÖ ${ep.name}: PASS`);
                  results.passed.push(ep.name);
                } else {
                  console.log(`‚ùå ${ep.name}: FAIL (status: ${res.status})`);
                  results.failed.push({ name: ep.name, reason: `Status ${res.status}` });
                }
              } catch (err) {
                console.log(`‚ùå ${ep.name}: FAIL (${err.message})`);
                results.failed.push({ name: ep.name, reason: err.message });
              }
            }
          }

          async function checkFrontend() {
            console.log('\nüñ•Ô∏è FRONTEND CHECKS\n');
            
            try {
              const indexRes = await httpGet(APP_URL);
              if (indexRes.status === 200 && indexRes.body.includes('<div id="root">')) {
                console.log('‚úÖ Index HTML: PASS');
                results.passed.push('Index HTML');
                
                // Extract and check JS asset
                const jsMatch = indexRes.body.match(/src="([^"]+\.js)"/);
                if (jsMatch) {
                  const jsRes = await httpGet(`${APP_URL}${jsMatch[1]}`);
                  if (jsRes.status === 200 && jsRes.headers['content-type']?.includes('javascript')) {
                    console.log(`‚úÖ JS Bundle: PASS (${Math.round(jsRes.body.length/1024)}KB)`);
                    results.passed.push('JS Bundle');
                  } else {
                    console.log(`‚ùå JS Bundle: FAIL (MIME: ${jsRes.headers['content-type']})`);
                    results.failed.push({ name: 'JS Bundle', reason: `Wrong MIME type: ${jsRes.headers['content-type']}` });
                  }
                }
                
                // Extract and check CSS asset
                const cssMatch = indexRes.body.match(/href="([^"]+\.css)"/);
                if (cssMatch) {
                  const cssRes = await httpGet(`${APP_URL}${cssMatch[1]}`);
                  if (cssRes.status === 200 && cssRes.headers['content-type']?.includes('css')) {
                    console.log('‚úÖ CSS Bundle: PASS');
                    results.passed.push('CSS Bundle');
                  } else {
                    console.log(`‚ùå CSS Bundle: FAIL`);
                    results.failed.push({ name: 'CSS Bundle', reason: 'Failed to load' });
                  }
                }
              } else {
                console.log('‚ùå Index HTML: FAIL');
                results.failed.push({ name: 'Index HTML', reason: `Status ${indexRes.status}` });
              }
            } catch (err) {
              console.log(`‚ùå Frontend: FAIL (${err.message})`);
              results.failed.push({ name: 'Frontend', reason: err.message });
            }
          }

          async function checkBrowserRendering() {
            console.log('\nüåê BROWSER RENDERING CHECKS\n');
            
            const puppeteer = require('puppeteer');
            let browser;
            
            try {
              browser = await puppeteer.launch({
                headless: 'new',
                args: ['--no-sandbox', '--disable-setuid-sandbox']
              });
              
              const page = await browser.newPage();
              const consoleErrors = [];
              const networkErrors = [];
              
              page.on('console', msg => {
                if (msg.type() === 'error') consoleErrors.push(msg.text());
              });
              
              page.on('requestfailed', req => {
                networkErrors.push(`${req.url()} - ${req.failure()?.errorText}`);
              });
              
              const response = await page.goto(APP_URL, { 
                waitUntil: 'networkidle2',
                timeout: 30000 
              });
              
              if (response && response.status() === 200) {
                console.log('‚úÖ Page Load: PASS');
                results.passed.push('Page Load');
              } else {
                console.log(`‚ùå Page Load: FAIL (${response?.status() || 'no response'})`);
                results.failed.push({ name: 'Page Load', reason: `Status ${response?.status()}` });
              }
              
              await new Promise(r => setTimeout(r, 3000));
              
              const rootContent = await page.evaluate(() => {
                const root = document.getElementById('root');
                return {
                  exists: !!root,
                  hasChildren: root ? root.children.length : 0
                };
              });
              
              if (rootContent.exists && rootContent.hasChildren > 0) {
                console.log(`‚úÖ React Rendered: PASS (${rootContent.hasChildren} children)`);
                results.passed.push('React Rendered');
              } else if (!rootContent.exists) {
                console.log('‚ùå React Rendered: FAIL (no #root)');
                results.failed.push({ name: 'React Rendered', reason: 'No #root element' });
              } else {
                console.log('‚ùå React Rendered: FAIL (empty #root - WHITE SCREEN)');
                results.failed.push({ name: 'React Rendered', reason: 'Empty #root - white screen detected' });
              }
              
              const uiCheck = await page.evaluate(() => ({
                buttonCount: document.querySelectorAll('button').length,
                textLength: document.body.innerText.length
              }));
              
              if (uiCheck.buttonCount > 0 || uiCheck.textLength > 100) {
                console.log(`‚úÖ UI Elements: PASS (${uiCheck.buttonCount} buttons, ${uiCheck.textLength} chars)`);
                results.passed.push('UI Elements');
              } else {
                console.log('‚ùå UI Elements: FAIL (no buttons or text)');
                results.failed.push({ name: 'UI Elements', reason: 'No interactive elements found' });
              }
              
              if (consoleErrors.length > 0) {
                console.log(`‚ö†Ô∏è Console Errors: ${consoleErrors.length} found`);
                consoleErrors.slice(0, 3).forEach(e => console.log(`   - ${e.substring(0, 80)}`));
                results.failed.push({ name: 'Console Clean', reason: `${consoleErrors.length} errors` });
              } else {
                console.log('‚úÖ Console Clean: PASS');
                results.passed.push('Console Clean');
              }
              
              if (networkErrors.length > 0) {
                console.log(`‚ö†Ô∏è Network Errors: ${networkErrors.length} failed requests`);
                results.failed.push({ name: 'Network Clean', reason: `${networkErrors.length} failed` });
              }
              
              await page.screenshot({ path: '/tmp/health-screenshot.png', fullPage: true });
              console.log('üì∏ Screenshot saved');
              
            } catch (err) {
              console.log(`‚ùå Browser Test: FAIL (${err.message})`);
              results.failed.push({ name: 'Browser Test', reason: err.message });
            } finally {
              if (browser) await browser.close();
            }
          }

          async function checkLogs() {
            console.log('\nüìã LOG CHECKS\n');
            
            try {
              const logging = new Logging({ projectId: 'sudoku-labs' });
              const log = logging.log('apphosting.googleapis.com%2Fapp');
              const since = new Date(Date.now() - 3600000).toISOString();
              
              const [entries] = await log.getEntries({
                filter: `timestamp >= "${since}"`,
                orderBy: 'timestamp desc',
                pageSize: 100
              });

              const errors = entries.filter(e => e.metadata.severity === 'ERROR');
              const startups = entries.filter(e => {
                const msg = typeof e.data === 'string' ? e.data : '';
                return msg.includes('STARTUP TCP probe succeeded');
              });

              console.log(`Total logs (1h): ${entries.length}`);
              console.log(`Errors: ${errors.length}`);
              console.log(`Successful startups: ${startups.length}`);

              if (errors.length === 0) {
                console.log('‚úÖ No errors in logs: PASS');
                results.passed.push('No Errors');
              } else {
                console.log(`‚ùå Found ${errors.length} errors: FAIL`);
                results.failed.push({ name: 'Error-free logs', reason: `${errors.length} errors found` });
                
                // Show first error
                const firstError = errors[0];
                const msg = typeof firstError.data === 'string' ? firstError.data : JSON.stringify(firstError.data);
                console.log(`  First error: ${msg.substring(0, 100)}...`);
              }

              if (startups.length > 0) {
                console.log('‚úÖ Container startups: PASS');
                results.passed.push('Container Health');
              }
            } catch (err) {
              console.log(`‚ö†Ô∏è Could not fetch logs: ${err.message}`);
            }
          }

          async function main() {
            console.log('üîç SUDOKU LABS HEALTH CHECK');
            console.log(`   Check type: ${checkType}`);
            console.log(`   Time: ${new Date().toISOString()}\n`);

            if (checkType === 'full' || checkType === 'api-only') await checkAPIs();
            if (checkType === 'full' || checkType === 'frontend-only') await checkFrontend();
            if (checkType === 'full' || checkType === 'frontend-only') await checkBrowserRendering();
            if (checkType === 'full' || checkType === 'logs-only') await checkLogs();

            console.log('\n' + '='.repeat(50));
            console.log('SUMMARY');
            console.log('='.repeat(50));
            console.log(`‚úÖ Passed: ${results.passed.length}`);
            console.log(`‚ùå Failed: ${results.failed.length}`);

            if (results.failed.length > 0) {
              console.log('\nFailed checks:');
              results.failed.forEach(f => console.log(`  - ${f.name}: ${f.reason}`));
            }

            // Output for GitHub Actions
            const output = results.failed.length === 0 ? 'healthy' : 'unhealthy';
            fs.appendFileSync(process.env.GITHUB_OUTPUT || '/dev/null', `status=${output}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT || '/dev/null', `failures=${JSON.stringify(results.failed)}\n`);
            
            process.exit(results.failed.length > 0 ? 1 : 0);
          }

          main().catch(err => {
            console.error('Health check failed:', err);
            process.exit(1);
          });
          EOF

      - name: Cleanup
        if: always()
        run: rm -f /tmp/firebase-sa.json

      - name: Upload Screenshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: health-check-screenshot
          path: /tmp/health-screenshot.png
          retention-days: 3
          if-no-files-found: ignore

      - name: Create Issue if Unhealthy
        if: failure()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue create \
            --repo ${{ github.repository }} \
            --title "[Health Check] Manual check detected failures" \
            --body "A manual health check run detected failures. Please investigate. Check Type: ${{ inputs.check_type }}. Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --label "auto-detected,awaiting-agent"
