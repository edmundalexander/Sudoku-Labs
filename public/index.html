<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sudoku Logic Lab</title>
    <!-- Favicon with multiple formats for better browser compatibility -->
    <link
      rel="icon"
      type="image/svg+xml"
      sizes="any"
      href="./favicon.svg?v=2"
    />
    <link
      rel="alternate icon"
      type="image/svg+xml"
      sizes="any"
      href="/Sudoku-Labs/favicon.svg?v=2"
    />
    <link rel="shortcut icon" type="image/svg+xml" href="./favicon.svg?v=2" />
    <link rel="apple-touch-icon" sizes="180x180" href="./favicon.svg?v=2" />
    <!-- Google Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined"
      rel="stylesheet"
    />
    <!-- Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Tailwind CSS (production build) -->
    <link id="tailwind-css" href="./styles.css" rel="stylesheet" />
    <!-- Accessibility overrides (load after main CSS) -->
    <link
      id="accessibility-css"
      href="./styles-accessibility.css"
      rel="stylesheet"
    />

    <!-- Boot monitor (visible overlay to capture load-time errors) -->
    <style>
      #boot-overlay { position:fixed; z-index:999999; right:12px; top:12px; max-width:420px; background:rgba(0,0,0,.75); color:#fff; padding:10px; font-family:monospace; font-size:12px; border-radius:6px; }
      #boot-overlay h4 { margin:0 0 6px 0; font-weight:700; font-size:13px; }
      #boot-overlay .msg { margin:0 0 4px 0; }
    </style>
    <div id="boot-overlay" aria-hidden="false">
      <h4>Boot status</h4>
      <div id="boot-log"></div>
    </div>
    <script>
      (function(){
        function bootLog(msg){
          try{ const el = document.getElementById('boot-log'); if(!el) return; const d = document.createElement('div'); d.className='msg'; d.textContent = (new Date()).toLocaleTimeString()+ ' - ' + msg; el.insertBefore(d, el.firstChild); }
          catch(e){console.warn('bootLog failed',e)}
          }
        window.bootLog = bootLog;
        window.addEventListener('error', function(ev){ bootLog('ERROR: '+ (ev.message || ev.error || ev.type)); });
        window.addEventListener('unhandledrejection', function(ev){ bootLog('UNHANDLED REJECTION: '+ (ev.reason && ev.reason.message) ); });
      })();
    </script>
    <script>
      // Fix CSS path for GitHub Pages and local /public/ dev server
      (function () {
        const basePath =
          window.location.hostname === "edmund-alexander.github.io"
            ? "/Sudoku-Labs/"
            : "./";
        const tail = document.getElementById("tailwind-css");
        const acc = document.getElementById("accessibility-css");
        // When serving from /public/ (local dev), keep CSS paths relative to the
        // current document (./) so they resolve to /public/styles*. When served
        // from root or GitHub Pages, use configured basePath.
        const isLocalInPublic = window.location.pathname.includes("/public/");
        const cssPrefix = isLocalInPublic ? "./" : basePath;
        if (tail) tail.href = cssPrefix + "styles.css";
        if (acc) acc.href = cssPrefix + "styles-accessibility.css";
        // Log CSS path fix to boot overlay
        try { window.bootLog && window.bootLog('CSS paths adjusted: ' + cssPrefix); } catch(e){}
      })();
    </script>
    <!-- React -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <!-- Babel Standalone for in-browser JSX compilation -->
    <script>
      // Load Babel standalone early so `text/babel` scripts can be compiled
      (function(){
        function insertBabel(){
          try{
            loadScript('https://unpkg.com/@babel/standalone/babel.min.js');
            window.bootLog && window.bootLog('Requested Babel via loadScript');
            return;
          } catch(e){
            var _s = document.createElement('script');
            _s.src = 'https://unpkg.com/@babel/standalone/babel.min.js';
            _s.onload = function(){ window.bootLog && window.bootLog('Babel loaded'); };
            _s.onerror = function(){ window.bootLog && window.bootLog('Failed to load Babel'); };
            document.currentScript.parentNode.insertBefore(_s, document.currentScript.nextSibling);
            window.bootLog && window.bootLog('Injected Babel script tag');
          }
        }
        insertBabel();
        // Poll for Babel presence and report
        (function waitForBabel(){
          var attempts = 0;
          function chk(){
            attempts++;
            if (window.Babel){ window.bootLog && window.bootLog('Babel detected'); return; }
            if (attempts > 30){ window.bootLog && window.bootLog('Babel not detected after timeout'); return; }
            setTimeout(chk,200);
          }
          chk();
        })();
      })();
    </script>

    <!-- Inline shim: define minimal legacy globals if services.js fails to load -->
    <script>
      (function () {
        // Provide a minimal `window.StorageService` stub to avoid runtime crashes
        // Do not declare `var StorageService` here to avoid duplicate-declaration errors
        try {
          if (typeof window !== "undefined") {
            if (!window.StorageService) {
              window.StorageService = {
                isAvailable: function () {
                  return false;
                },
                getUserSession: function () {
                  return null;
                },
                getUserId: function () {
                  return "guest";
                },
                getUnlockedThemes: function () {
                  return ["default"];
                },
                getUnlockedSoundPacks: function () {
                  return ["classic"];
                },
                getActiveTheme: function () {
                  return "default";
                },
                getActiveSoundPack: function () {
                  return "classic";
                },
                isUserAuthenticated: function () {
                  return false;
                },
                saveUserSession: function () {},
                setUserSession: function () {},
                saveUnlockedThemes: function () {},
                saveUnlockedSoundPacks: function () {},
                getGameStats: function () {
                  return {};
                },
                saveGameStats: function () {},
              };
            }
          }
        } catch (err) {
          // ignore shim errors
        }
      })();
    </script>
    </head>
  <body class="bg-gray-50 dark:bg-gray-900 transition-colors duration-300">
    <div id="root"></div>
    <!-- Prevent dark mode flash: Check localStorage and apply dark class ASAP -->
    <script>
      (function () {
        const savedTheme = localStorage.getItem("theme");
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        if (savedTheme === "dark" || (!savedTheme && prefersDark)) {
          document.documentElement.classList.add("dark");
        }
      })();
    </script>

    <!-- Cache/version guard: uses deployed ETag (commit) as version so any push forces a fresh load -->
    <script>
      (function () {
        const fetchVersion = async () => {
          try {
            const res = await fetch(window.location.href, {
              method: "HEAD",
              cache: "no-cache",
            });
            const etag = res.headers.get("etag");
            if (etag) return etag.replace(/"/g, "");
          } catch (e) {
            console.warn("Version HEAD fetch failed:", e);
          }
          return "local-dev"; // fallback for offline/local
        };

        const clearCaches = async () => {
          try {
            localStorage.clear();
            sessionStorage.clear();
            if ("caches" in window) {
              const keys = await caches.keys();
              await Promise.all(keys.map((key) => caches.delete(key)));
            }
          } catch (e) {
            console.warn("Cache clear skipped:", e);
          }
        };

        (async () => {
          const appVersion = await fetchVersion();
          const stored = localStorage.getItem("APP_VERSION");
          if (stored !== appVersion) {
            await clearCaches();
            localStorage.setItem("APP_VERSION", appVersion);
            location.reload();
            return;
          }
          window.APP_VERSION = appVersion;
        })();
      })();
    </script>

    <!-- Load configuration from config files -->
    <!-- Priority: config.local.js (dev) → config.production.example.js (GitHub Pages) → defaults -->
    <script>
      // Default config values - will be overwritten by config files if they exist
      window.CONFIG = {
        GAS_URL: null, // Set a default or leave as null
        BASE_PATH: "", // Default to root (no subdirectory)
      };
    </script>

    <!-- Dynamic path resolution for different deployment environments -->
    <script>
      // Detect environment:
      // - GitHub Pages: files are in root (./src/, ./config/)
      // - Local dev served from root: files are also in root (./src/, ./config/)
      // - Local dev served from public/: files are in parent (../src/, ../config/)
      const isGitHubPages = window.location.hostname.includes("github.io");
      const isLocalInPublic = window.location.pathname.includes("/public/");
      const pathPrefix = isLocalInPublic ? "../" : "./";

      // Helper to load scripts with correct path, dedupe and add cache-busting
      function loadScript(src, attributes = {}) {
        try {
          const version = window.APP_VERSION || Date.now();
          const sep = src.includes("?") ? "&" : "?";
          const fullSrc = pathPrefix + src + sep + "v=" + encodeURIComponent(version);

          // Avoid inserting the same script twice
          if (document.querySelector('script[src="' + fullSrc + '"]') || document.querySelector('script[src="' + pathPrefix + src + '"]')) {
            return;
          }

          const script = document.createElement("script");
          script.src = fullSrc;
          script.async = false; // preserve execution order for dependent scripts
          script.onload = function(){ window.bootLog && window.bootLog('Loaded ' + src); };
          script.onerror = function (ev) {
            window.bootLog && window.bootLog('Failed to load script: ' + src + ' (' + (ev && ev.type) + ')');
            console.error('Failed to load script:', fullSrc, ev && ev.type);
          };
          Object.entries(attributes).forEach(([key, value]) => {
            if (value === true) script.setAttribute(key, "");
            else script.setAttribute(key, value);
          });
          document.currentScript.parentNode.insertBefore(
            script,
            document.currentScript.nextSibling
          );
        } catch (e) {
          // If anything goes wrong, don't block page load
          console.warn('loadScript failed', e);
        }
      }
    </script>

      <!-- Load React app (JSX) only after services have initialized to avoid race conditions -->
      <script>
        (function waitForServicesAndLoadApp() {
          var maxTries = 50;
          var interval = 100; // ms
          var tries = 0;
          function loadAppScripts() {
            loadScript("src/app.jsx", { type: "text/babel", "data-presets": "env,react" });
            loadScript("src/admin.jsx", { type: "text/babel", "data-presets": "env,react" });
            loadScript("src/admin-access.js");
          }
          function check() {
            if (window.StorageService && typeof window.StorageService.getUserSession === "function") {
              loadAppScripts();
              return;
            }
            tries++;
            if (tries > maxTries) {
              // Fallback: still attempt to load app scripts
              loadAppScripts();
              return;
            }
            setTimeout(check, interval);
          }
          check();
        })();
      </script>

    <!-- Configuration files (load conditionally to avoid conflicts) -->
    <script>
      // Only load production config if we're on GitHub Pages
      if (!isGitHubPages) {
        loadScript("config/config.local.js");
        loadScript("config/admin.local.js");
      } else {
        // Production: only load production config
        loadScript("config/config.local.js");
      }
    </script>

    <!-- Load modular JavaScript files (plain JS, loaded before React components) -->
    <!-- Order matters: constants → utils → sound → services → app -->
    <script>
      loadScript("src/constants.js");
    </script>
    <script>
      loadScript("src/utils.js");
    </script>
    <script>
      loadScript("src/sound.js");
    </script>
    <script>
      loadScript("src/services.js");
    </script>

    <!-- React app and admin console are loaded by the deferred loader above -->
  </body>
</html>
